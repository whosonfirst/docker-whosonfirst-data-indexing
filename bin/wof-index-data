#!/bin/sh
# -*-sh-*-

GIT=`which git`
S3_SYNC=`which wof-s3-sync`
ES_INDEX_TOOL=`which wof-es-index`	# this can't be ported to Go soon enough... (20190122/thisisaaronland)

ES_CONFIG="localhost#9200#index"
S3_DSN=""

GITHUB_ORG="whosonfirst-data"

DATA="/usr/local/data"
DRYRUN=""
ALL=""

# https://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/
# 'getopts' is your friend; 'getopt' is your weird friend

while getopts "t:d:e:s:g:anh" opt
do
    case "${opt}" in
	a  ) ALL=1
	     ;;
	d  ) DATA=$2
	     ;;
	e  ) ES_CONFIG=$OPTARG
	     ;;
	g  ) GITHUB_ORG=$OPTARG
	     ;;
        h  ) USAGE=1
	     ;;
	n  ) DRYRUN=1
	     ;;
	s  ) S3_DSN=$OPTARG
	     ;;
	\? ) USAGE=1
	     break;
    esac
done

shift $((OPTIND -1))

if [ "${USAGE}" = "1" ]
then
    echo "usage: ./index-data -options"
    echo "options:"
    echo "...please write me"
    exit 0
fi

TO_INDEX=$@

for REPO in $TO_INDEX
do
    echo "TO INDEX: '${REPO}'"
done

echo "ES CONFIG '${ES_CONFIG}'"

ES_HOST=`echo ${ES_CONFIG} | awk -F '#' '{ print $1 }'`
ES_PORT=`echo ${ES_CONFIG} | awk -F '#' '{ print $2 }'`
ES_INDEX=`echo ${ES_CONFIG} | awk -F '#' '{ print $3 }'`

# basic sanity checking on ES_ and S3_DSN variables should go here....

echo "ES HOST: '${ES_HOST}'"
echo "ES PORT: '${ES_PORT}'"
echo "ES INDEX: '${ES_INDEX}'"
echo "S3 DSN: '${S3_DSN}'"
echo "DRYRUN: '${DRYRUN}'"
echo "INDEX ALL: '${ALL}'"

mkdir -p /usr/local/data

for REPO_NAME in $TO_INDEX
do

    cd ${DATA}

    # see the --depth 2 part? that's important / it means we don't fetch the entire
    # history but just enough to do `git log HEAD^..HEAD` below (20190818/straup)
    
    echo "${GIT} clone --depth 2 https://github.com/${GITHUB_ORG}/${REPO_NAME}.git"
    
    ${GIT} clone --depth 2 https://github.com/${GITHUB_ORG}/${REPO_NAME}.git

    if [ $? -ne 0 ]
    then
	echo "Failed to clone ${REPO_NAME}"
	continue
    fi
    
    REPO_PATH="${DATA}/${REPO_NAME}"
    cd ${REPO_PATH}

    INDEX_MODE="filelist"
    INDEX_PATH="${REPO_PATH}/index.txt"

    # as of this writing most (all...) of the time savings doing it this way is targeted at
    # flights and because of the way we are exporting them (flights) â€“ which involves using a
    # two-pass export, first in go and then again using the more-complete python exporter 
    # basically a pure-go port of the py-mapzen-whosonfirst-export code can't happen soon
    # enough but until then all of the effeciencies here depend on exporting flights with
    # something like this (where utils/python/export.py is bundled with the flights repo):
    #
    # git status --porcelain --untracked-files=all | egrep '.geojson' | awk '{ print $$2 }' > new.txt
    # python utils/python/export.py -r . -f new.txt
    # rm new.txt
    #
    # (20190123/thisisaaronland)

    if [ "${ALL}" = "1" ]
    then
	INDEX_MODE="repo"
	INDEX_PATH="${REPO_PATH}"
    else

	echo "${GIT} log --name-only --pretty=format:'' HEAD^..HEAD | grep geojson > ${INDEX_PATH}"
	
	${GIT} log --name-only --pretty=format:'' HEAD^..HEAD | grep geojson > ${INDEX_PATH}

	if [ $? -ne 0 ]
	then
	    echo "Failed to generate ${INDEX_PATH}"

	    cd -
	    rm -rf ${REPO_PATH}
	    continue
	fi

	COUNT_LINES=`wc -l ${INDEX_PATH}`
	echo "RECORDS TO PROCESS: ${COUNT_LINES}"
	
    fi

    echo "index ${REPO_PATH} in '${INDEX_MODE}' mode, reading from ${INDEX_PATH}"

    # running wof-s3-sync with -verbose enabled produces _way_ to much stuff in an ECS context
    
    echo ${S3_SYNC} -dsn "${S3_DSN}" -mode ${INDEX_MODE} ${INDEX_PATH}
	
    if [ "${DRYRUN}" = "" ]
    then
	${S3_SYNC} -dsn "${S3_DSN}" -mode ${INDEX_MODE} ${INDEX_PATH}
    fi
    
    echo ${ES_INDEX_TOOL} -b -c 1500 --host ${ES_HOST} --port ${ES_PORT} --index ${ES_INDEX} --mode ${INDEX_MODE} ${INDEX_PATH}
    
    if [ "${DRYRUN}" = "" ]
    then
	${ES_INDEX_TOOL} -b -c 1500 --host ${ES_HOST} --port ${ES_PORT} --index ${ES_INDEX} -m ${INDEX_MODE} ${INDEX_PATH}
    fi
    
    if [ -f ${INDEX_PATH} ]
    then
	rm ${INDEX_PATH}
    fi

    cd -
    rm -rf ${REPO_PATH}
    
done
